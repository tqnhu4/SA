Right! Building on your basic NGINX knowledge, here's an advanced NGINX learning roadmap with commands and examples, presented clearly in English with helpful icons. This will equip you with the skills to optimize performance, enhance security, and manage complex traffic flows.

---

# üöÄ Advanced NGINX Learning Roadmap

This roadmap delves into more sophisticated NGINX configurations, covering crucial aspects like SSL/TLS, load balancing, caching, and advanced request handling‚Äîessential for production environments.

## üõ°Ô∏è 1. SSL/TLS Configuration (HTTPS)

Securing your website with HTTPS is a non-negotiable in modern web development. NGINX can terminate SSL/TLS connections efficiently.

### Purpose

* Encrypt communication between clients and your server.
* Ensure data integrity and authenticity.
* Improve SEO ranking (Google favors HTTPS).

### Key Concepts

* **SSL/TLS Certificates**: Digital files that bind a cryptographic key to an organization's details. They are issued by Certificate Authorities (CAs).
* **Private Key**: A secret key stored on your server, used for decryption.
* **Public Key (in Certificate)**: Shared with clients for encryption.
* **Port 443**: Standard port for HTTPS traffic.

### Workflow with Let's Encrypt (Certbot)

Let's Encrypt provides free, automated SSL certificates. Certbot is the recommended client for this.

1.  **Install Certbot:**
    ```bash
    sudo apt install certbot python3-certbot-nginx
    ```
    * **Explanation**: `certbot` is the tool, `python3-certbot-nginx` is the NGINX plugin for Certbot.

2.  **Ensure NGINX server block is configured for HTTP (port 80) and `server_name` is correct:**
    Make sure your `sites-available/yourdomain.com` (from basic roadmap) listens on port 80 and has the correct `server_name`. Certbot uses this to verify domain ownership.

3.  **Run Certbot for NGINX:**
    ```bash
    sudo certbot --nginx -d yourdomain.com -d www.yourdomain.com
    ```
    * **Explanation**:
        * `--nginx`: Tells Certbot to use the NGINX plugin.
        * `-d yourdomain.com`: Specifies the domain(s) for which to obtain the certificate. You can add multiple `-d` flags.
    * Certbot will guide you through prompts:
        * Enter email for urgent renewal notices.
        * Agree to terms of service.
        * Choose whether to redirect HTTP to HTTPS (recommended).
    * Certbot will automatically modify your NGINX configuration to include SSL directives and set up automatic renewals.

4.  **Verify NGINX configuration (Certbot does this automatically, but it's good practice):**
    ```bash
    sudo nginx -t
    ```

5.  **Check SSL status (optional, but good for verification):**
    Visit `https://www.ssllabs.com/ssltest/` and enter your domain name to get a detailed report on your SSL/TLS configuration.

6.  **Understanding Auto-Renewal:**
    Certbot sets up a cron job or systemd timer for automatic renewals. You can test it:
    ```bash
    sudo certbot renew --dry-run
    ```

### Example NGINX SSL Configuration (Generated by Certbot)

After Certbot runs, your `sites-available/yourdomain.com` file will be updated, looking something like this:

```nginx
server {
    listen 80;
    listen [::]:80;
    server_name yourdomain.com www.yourdomain.com;
    return 301 https://$host$request_uri; # HTTP to HTTPS redirect
}

server {
    listen 443 ssl http2; # Listen on port 443 for HTTPS, enable HTTP/2
    listen [::]:443 ssl http2;
    server_name yourdomain.com www.yourdomain.com;

    root /var/www/yourdomain.com/html; # Your web content root
    index index.html;

    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem; # Path to full certificate chain
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem; # Path to private key
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_protocols TLSv1.2 TLSv1.3; # Recommended secure protocols
    ssl_prefer_server_ciphers on;
    ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH"; # Strong ciphers
    ssl_dhparam /etc/nginx/ssl-dhparams.pem; # Diffie-Hellman parameters (generate with 'sudo openssl dhparam -out /etc/nginx/ssl-dhparams.pem 2048')

    # Add other security headers (see section 5)
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;

    location / {
        try_files $uri $uri/ =404;
    }
    # ... other locations or proxy_pass directives
}
```

---

## ‚öñÔ∏è 2. Load Balancing

Distribute incoming traffic across multiple backend servers to improve availability, scalability, and performance.

### Purpose

* Increase application availability (if one server fails, others handle traffic).
* Improve response times by distributing load.
* Scale applications horizontally.

### Key Concepts

* **Upstream Block**: Defines a group of backend servers.
* **Load Balancing Methods**:
    * **Round Robin (default)**: Requests are distributed evenly among servers.
    * **Least Connected**: Directs new requests to the server with the fewest active connections.
    * **IP Hash**: Ensures requests from the same client IP always go to the same server.

### Example: Basic Load Balancing

1.  **Define an `upstream` block in `nginx.conf` (or a separate file included in `http` block):**
    ```nginx
    # /etc/nginx/conf.d/upstreams.conf (or similar)
    upstream backend_servers {
        server 192.168.1.101:8000; # IP and port of backend server 1
        server 192.168.1.102:8000; # IP and port of backend server 2
        # You can add more servers here
        # server backend3.internal.com:8000;

        # Optional: Least Connected method
        # least_conn;
    }
    ```

2.  **Configure a `server` block to use the `upstream` group:**
    ```nginx
    # /etc/nginx/sites-available/my-load-balanced-app.com
    server {
        listen 80;
        server_name my-load-balanced-app.com;

        location / {
            proxy_pass http://backend_servers; # Use the upstream block name
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
    ```
3.  **Enable the site, test, and reload NGINX.**

---

## ‚è±Ô∏è 3. Caching

Improve website performance by storing frequently accessed content closer to the user or in memory/disk.

### Purpose

* Reduce load on backend servers.
* Speed up content delivery to clients.
* Save bandwidth.

### Key Concepts

* **Proxy Cache**: NGINX stores responses from backend servers.
* **Cache Keys**: How NGINX identifies unique cached items.
* **Cache Zones**: Defines where and how cached data is stored.

### Example: Basic Proxy Caching

1.  **Define a `proxy_cache_path` directive in the `http` block of `nginx.conf`:**
    ```nginx
    # In /etc/nginx/nginx.conf (inside the http {} block)
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m inactive=60m max_size=1g;
    ```
    * **Explanation**:
        * `/var/cache/nginx`: Path to the cache directory.
        * `levels=1:2`: Creates a two-level hierarchy of subdirectories (e.g., `c/29/`) to store cached files, improving lookup performance.
        * `keys_zone=my_cache:10m`: Defines a shared memory zone named `my_cache` of 10MB to store cache keys and metadata.
        * `inactive=60m`: Specifies that data that has not been accessed for 60 minutes will be removed from the cache.
        * `max_size=1g`: Sets the maximum size of the cache to 1GB.

2.  **Enable caching in your `server` or `location` block:**
    ```nginx
    # In your site's server block (e.g., /etc/nginx/sites-available/app.example.com)
    server {
        # ... (other directives like listen, server_name, etc.)

        location / {
            proxy_pass http://backend_servers; # Or http://localhost:3000;
            proxy_cache my_cache; # Use the defined cache zone
            proxy_cache_valid 200 302 10m; # Cache successful responses (200, 302) for 10 minutes
            proxy_cache_valid 404 1m;     # Cache 404 responses for 1 minute
            proxy_cache_bypass $http_pragma $http_authorization; # Don't cache requests with these headers
            add_header X-Proxy-Cache $upstream_cache_status; # Debugging header
        }
    }
    ```
    * **`proxy_cache my_cache`**: Activates caching for this `location` using the `my_cache` zone.
    * **`proxy_cache_valid`**: Defines how long different HTTP status codes are considered valid in the cache.
    * **`proxy_cache_bypass`**: Prevents caching for requests that have specific headers (e.g., `Pragma: no-cache` or `Authorization`).
    * **`add_header X-Proxy-Cache $upstream_cache_status`**: A debugging header that shows if the request was a `HIT`, `MISS`, `EXPIRED`, etc.

3.  **Ensure NGINX cache directory exists and has correct permissions:**
    ```bash
    sudo mkdir -p /var/cache/nginx
    sudo chown www-data:www-data /var/cache/nginx
    ```
4.  **Test and reload NGINX.**

---

## ‚è© 4. URL Rewrites and Redirects

Control how NGINX handles URLs, from simple redirects to complex URL manipulations.

### Purpose

* Redirect old URLs to new ones.
* Enforce canonical URLs (e.g., add or remove `www`).
* Route requests based on URL patterns.

### Key Directives

* **`rewrite`**: Powerful but complex, uses regular expressions to change URLs.
* **`return`**: Simpler and more efficient for basic redirects.

### Example: Redirects

1.  **HTTP to HTTPS redirect (already covered by Certbot, but good to know):**
    ```nginx
    server {
        listen 80;
        server_name yourdomain.com www.yourdomain.com;
        return 301 https://$host$request_uri;
    }
    ```
    * **`return 301`**: Returns a permanent (301) redirect status code. `$host` is the requested hostname, `$request_uri` is the full request URI.

2.  **Redirecting an old page to a new page:**
    ```nginx
    location /old-page.html {
        return 301 /new-page.html;
    }
    ```

3.  **Redirecting non-www to www:**
    ```nginx
    server {
        listen 80;
        listen 443 ssl http2;
        server_name yourdomain.com; # Non-www domain

        # Add SSL directives if this block handles HTTPS
        # ssl_certificate ...;
        # ssl_certificate_key ...;

        return 301 $scheme://www.yourdomain.com$request_uri; # Redirect to www
    }

    server {
        listen 80;
        listen 443 ssl http2;
        server_name www.yourdomain.com; # Primary www domain
        # ... (your main website configuration goes here)
    }
    ```

### Example: Rewrites (More Complex)

```nginx
server {
    # ...
    location /blog/ {
        # Rewrites /blog/post-title to /index.php?page=blog&title=post-title
        rewrite ^/blog/([a-zA-Z0-9-]+)/?$ /index.php?page=blog&title=$1 last;
        # 'last' means stop processing this location and search for a new location based on the rewritten URI
    }

    location ~ \.php$ {
        # Handle PHP files (often passed to PHP-FPM)
        include snippets/fastcgi-php.conf; # Common include for PHP-FPM
        fastcgi_pass unix:/run/php/php7.4-fpm.sock;
    }
}
```
* **`rewrite regex replacement [flag]`**: A powerful directive. Use `^` for start of string, `$` for end. `([a-zA-Z0-9-]+)` captures a group.

---

## üìà 5. Performance Optimizations & Security Headers

Fine-tune NGINX for better performance and enhance security with HTTP headers.

### Purpose

* Improve website loading speed.
* Protect against common web vulnerabilities.

### Example: `nginx.conf` (within `http` block)

```nginx
# Gzip Compression (reduces file size for transfer)
gzip on;
gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

# Client Timeout Settings
client_body_timeout 12s; # Time for client to send request body
client_header_timeout 12s; # Time for client to send request header
keepalive_timeout 15s; # Keep-alive connection timeout

# Buffer Sizes
client_body_buffer_size 128k;
client_header_buffer_size 1k;
large_client_header_buffers 4 8k;

# Security Headers (add these to your server or location blocks)
# You often add these within the 'server' block after SSL configuration

# HTTP Strict Transport Security (HSTS) - Force HTTPS for future visits
# add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

# X-Frame-Options (Prevent Clickjacking)
# add_header X-Frame-Options "SAMEORIGIN"; # Or DENY

# X-Content-Type-Options (Prevent MIME type sniffing)
# add_header X-Content-Type-Options "nosniff";

# X-XSS-Protection (Cross-Site Scripting protection)
# add_header X-XSS-Protection "1; mode=block";

# Referrer-Policy (Control referrer information sent to other sites)
# add_header Referrer-Policy "no-referrer-when-downgrade";

# Content-Security-Policy (CSP) - Advanced, restricts resources a page can load (complex)
# add_header Content-Security-Policy "default-src 'self'; script-src 'self' https://trusted.cdn.com;";
```

### Explanation

* **Gzip Compression**: Compresses files before sending them to the client, speeding up delivery.
* **Client/Keep-alive Timeouts**: Optimizes connection handling and resource usage.
* **Buffer Sizes**: Prevents NGINX from writing to temporary files unnecessarily, improving performance.
* **Security Headers**: Important HTTP response headers that help protect against common web attacks. These should generally be added to your `server` block for HTTPS.

---

## üõ†Ô∏è 6. NGINX Modules & Customization

NGINX's functionality can be extended with various modules. Some are compiled in by default, others need to be enabled or custom-compiled.

### Purpose

* Add specific features (e.g., geo-IP blocking, advanced HTTP request handling).
* Monitor NGINX (status page).

### Example: Basic Status Page

NGINX can expose a simple status page to monitor active connections.

1.  **Ensure `ngx_http_stub_status_module` is enabled (usually compiled by default).**

2.  **Add a `location` block to a `server` (e.g., in a dedicated `status.conf` file or your main site):**
    ```nginx
    # /etc/nginx/sites-available/nginx-status.conf
    server {
        listen 80;
        server_name your_server_ip; # Or a specific subdomain like status.yourdomain.com

        location /nginx_status {
            stub_status on; # Enable the status page
            allow 127.0.0.1; # Allow access only from localhost
            deny all;        # Deny access from anywhere else
        }
    }
    ```
    * **`stub_status on`**: Activates the status page module.
    * **`allow`/`deny`**: Basic access control based on IP address.

3.  **Enable the site, test, and reload NGINX.**

4.  **Access in browser:** `http://your_server_ip/nginx_status` (from your allowed IP).

---

## üöÄ What's Next?

You're now on your way to becoming an NGINX expert! Here are further advanced topics to explore:

* **NGINX Plus**: The commercial version with additional features like active health checks, advanced load balancing algorithms, and session persistence.
* **WebSockets Proxying**: Configuring NGINX to proxy WebSocket connections.
* **GRPC Proxying**: Setting up NGINX as a proxy for gRPC services.
* **Rate Limiting**: Throttling client requests to prevent abuse or overload.
* **Authentication (Basic Auth, OAuth2 integration)**: Securing parts of your website.
* **ModSecurity (WAF)**: Integrating a Web Application Firewall for deeper security.
* **Lua Scripting in NGINX**: Extending NGINX functionality with Lua for complex logic.
* **Troubleshooting & Debugging**: Using NGINX logs effectively, `strace`, `lsof`.
* **NGINX with Docker/Containers**: Deploying NGINX in containerized environments.

Which of these advanced areas would you like to explore first?